{"id":"dd15152d-7d43-4e8f-81ed-1992983189e4","data":{"nodes":[{"id":"FileCSVComponent-xIEjA","type":"genericNode","position":{"x":526.0456585514618,"y":270.16424686213844},"data":{"type":"FileCSVComponent","node":{"template":{"_type":"Component","csv_file":{"trace_as_metadata":true,"file_path":"dd15152d-7d43-4e8f-81ed-1992983189e4/2024-09-14_00-54-40_rag_questions_aidevs.csv","fileTypes":["csv"],"list":false,"required":false,"placeholder":"","show":true,"value":"","name":"csv_file","display_name":"CSV File","advanced":false,"dynamic":false,"info":"Upload a CSV file to convert to a list of Data objects","title_case":false,"type":"file"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.custom import Component\r\nfrom langflow.io import FileInput, Output\r\nfrom langflow.schema import Data\r\nfrom langflow.base.data.utils import TEXT_FILE_TYPES\r\nimport csv\r\nfrom pathlib import Path\r\n\r\nclass FileCSVComponent(Component):\r\n    display_name = \"File CSV to Data List\"\r\n    description = \"Load a CSV file and convert it to a list of Data objects\"\r\n    icon = \"file-spreadsheet\"\r\n\r\n    inputs = [\r\n        FileInput(\r\n            name=\"csv_file\",\r\n            display_name=\"CSV File\",\r\n            file_types=[\"csv\"],\r\n            info=\"Upload a CSV file to convert to a list of Data objects\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"data_list\", display_name=\"Data List\", method=\"load_csv_to_data\"),\r\n    ]\r\n\r\n    def load_csv_to_data(self) -> list[Data]:\r\n        try:\r\n            if not self.csv_file:\r\n                raise ValueError(\"Please upload a CSV file to use this component.\")\r\n\r\n            resolved_path = self.resolve_path(self.csv_file)\r\n            file_path = Path(resolved_path)\r\n\r\n            if file_path.suffix.lower() != '.csv':\r\n                raise ValueError(\"The uploaded file must be a CSV file.\")\r\n\r\n            result = []\r\n            with open(file_path, 'r', newline='', encoding='utf-8') as csvfile:\r\n                csv_reader = csv.DictReader(csvfile)\r\n                for row in csv_reader:\r\n                    result.append(Data(data=row))\r\n\r\n            if not result:\r\n                self.status = \"The CSV file is empty.\"\r\n                return []\r\n\r\n            self.status = result\r\n            return result\r\n\r\n        except csv.Error as e:\r\n            error_message = f\"CSV parsing error: {str(e)}\"\r\n            self.status = error_message\r\n            return [Data(data={\"error\": error_message})]\r\n\r\n        except Exception as e:\r\n            error_message = f\"An error occurred: {str(e)}\"\r\n            self.status = error_message\r\n            return [Data(data={\"error\": error_message})]","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false}},"description":"### 1. Load the provided Datast (CSV) \n\nHere you will load the dataset that will be sent to your flow for evaluation","icon":"file-spreadsheet","base_classes":["Data"],"display_name":"File CSV to Data List","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"data_list","display_name":"Data List","method":"load_csv_to_data","value":"__UNDEFINED__","cache":true}],"field_order":["csv_file"],"beta":false,"edited":true,"lf_version":"1.0.17"},"id":"FileCSVComponent-xIEjA","description":"Load a CSV file and convert it to a list of Data objects","display_name":"JSON Flow Executor"},"selected":false,"width":384,"height":370,"positionAbsolute":{"x":526.0456585514618,"y":270.16424686213844},"dragging":false},{"id":"CSVAppender-shqpS","type":"genericNode","position":{"x":1456.5199596068176,"y":252.24274775312358},"data":{"type":"CSVAppender","node":{"template":{"_type":"Component","data":{"trace_as_input":true,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"value":"","name":"data","display_name":"Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The data to append to the CSV file. Can be a Data object, a dictionary, or a list of either.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import csv\r\nimport os\r\nfrom typing import List, Union, Dict\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import DataInput, MessageInput, Output\r\nfrom langflow.schema.message import Message\r\nfrom langflow.schema import Data\r\n\r\nclass CSVAppender(Component):\r\n    display_name = \"CSV Appender\"\r\n    description = \"Appends data to a CSV file and returns the full file path.\"\r\n    icon = \"üìä\"\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"data\",\r\n            display_name=\"Data\",\r\n            info=\"The data to append to the CSV file. Can be a Data object, a dictionary, or a list of either.\",\r\n        ),\r\n        MessageInput(\r\n            name=\"file_path\",\r\n            display_name=\"File Path\",\r\n            info=\"The path where the CSV file will be created or appended to.\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"output_path\", display_name=\"Output Path\", method=\"append_to_csv\"),\r\n    ]\r\n\r\n    def _extract_data(self, input_data: Union[Data, Dict, List]) -> List[Dict]:\r\n        if isinstance(input_data, Data):\r\n            return [input_data.data] if isinstance(input_data.data, dict) else input_data.data\r\n        elif isinstance(input_data, dict):\r\n            return [input_data]\r\n        elif isinstance(input_data, list):\r\n            return [item.data if isinstance(item, Data) else item for item in input_data]\r\n        else:\r\n            raise ValueError(f\"Unsupported data type: {type(input_data)}\")\r\n\r\n    def append_to_csv(self) -> Message:\r\n        try:\r\n            file_path = self.file_path.text\r\n            data = self._extract_data(self.data)\r\n\r\n            if not data:\r\n                result = \"No data to append.\"\r\n                self.status = result\r\n                return Message(text=result)\r\n\r\n            file_exists = os.path.isfile(file_path)\r\n\r\n            if not file_exists:\r\n                # Create new file with headers\r\n                fieldnames = list(data[0].keys())\r\n                with open(file_path, 'w', newline='') as csvfile:\r\n                    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\r\n                    writer.writeheader()\r\n                print(f\"Created new file: {file_path}\")\r\n            else:\r\n                # Read existing CSV to get column names\r\n                with open(file_path, 'r', newline='') as csvfile:\r\n                    reader = csv.reader(csvfile)\r\n                    fieldnames = next(reader)  # Get the first row as column names\r\n\r\n            # Append data to the CSV file\r\n            with open(file_path, 'a', newline='') as csvfile:\r\n                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\r\n\r\n                for row in data:\r\n                    if isinstance(row, dict):\r\n                        # Only write fields that exist in the CSV\r\n                        writer.writerow({k: row.get(k, '') for k in fieldnames})\r\n                    else:\r\n                        result = f\"Error: Unexpected data format: {type(row)}\"\r\n                        self.status = result\r\n                        return Message(text=result)\r\n\r\n            action = \"appended to\" if file_exists else \"written to new\"\r\n            full_path = os.path.abspath(file_path)\r\n            result = f\"Data successfully {action} {full_path}\"\r\n            self.status = result\r\n            return Message(text=result)\r\n\r\n        except Exception as e:\r\n            result = f\"Error handling CSV file: {str(e)}\"\r\n            self.status = result\r\n            return Message(text=result)","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"file_path":{"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"value":"aidevs-week-2-eval-result.csv","name":"file_path","display_name":"File Path","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The path where the CSV file will be created or appended to.","title_case":false,"type":"str","_input_type":"MessageInput"}},"description":"Appends data to a CSV file and returns the full file path.","icon":"üìä","base_classes":["Message"],"display_name":"Save data to CSV File","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"output_path","display_name":"Output Path","method":"append_to_csv","value":"__UNDEFINED__","cache":true}],"field_order":["data","file_path"],"beta":false,"edited":true,"lf_version":"1.0.17"},"id":"CSVAppender-shqpS"},"selected":false,"width":384,"height":370,"positionAbsolute":{"x":1456.5199596068176,"y":252.24274775312358},"dragging":false},{"id":"BatchFlowExecutorComponent-BehTi","type":"genericNode","position":{"x":992.3372559075567,"y":191.6643185144561},"data":{"type":"BatchFlowExecutorComponent","node":{"template":{"_type":"Component","input_data_list":{"trace_as_metadata":true,"list":true,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"input_data_list","value":"","display_name":"Input Data List","advanced":false,"input_types":["Data"],"dynamic":false,"info":"A list of Data objects, each containing 'question' and 'ground_truth' keys to be passed to the flow.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import re\r\nfrom typing import List, Any, Dict, Union\r\nfrom langflow.custom import Component\r\nfrom langflow.io import DataInput, Output, MessageInput, DropdownInput\r\nfrom langflow.schema import Data\r\nfrom loguru import logger\r\n\r\nimport os\r\nos.environ[\"LANGWATCH_API_KEY\"] = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0aW1lc3RhbXAiOjE3MjU0NTYzODA2NDEsInJhbmQiOjAuMTEyNzU0MDQ2Nzk4ODM0NiwiaWF0IjoxNzI1NDU2MzgwfQ.-bazR95X0uLStKbYhId7M4O6DZkoxgRfJfSR-ZQzHj0\"\r\n\r\nclass BatchFlowExecutorComponent(Component):\r\n    display_name = \"Batch Flow Executor - AI Devs\"\r\n    description = \"Execute a specific Langflow by name with a list of input messages and email address.\"\r\n    icon = \"list-restart\"\r\n\r\n    def get_flow_names(self) -> List[str]:\r\n        flow_data = self.list_flows()\r\n        return [flow_data.data[\"name\"] for flow_data in flow_data]\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"input_data_list\",\r\n            display_name=\"Input Data List\",\r\n            info=\"A list of Data objects, each containing 'question' and 'ground_truth' keys to be passed to the flow.\",\r\n            is_list=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"flow_name\",\r\n            display_name=\"Flow Name\",\r\n            info=\"The name of the flow to run.\",\r\n            options=[],\r\n            refresh_button=True,\r\n        ),\r\n        MessageInput(\r\n            name=\"email_address\",\r\n            display_name=\"Email Address\",\r\n            info=\"Email address for notifications or identification.\",\r\n        ),\r\n        MessageInput(\r\n            name=\"user_name\",\r\n            display_name=\"User Name\",\r\n            info=\"Full name of the user.\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(display_name=\"Output Data List\", name=\"output_data_list\", method=\"execute_flow_batch\"),\r\n    ]\r\n\r\n    def validate_email(self, email):\r\n        pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\r\n        return re.match(pattern, email) is not None\r\n\r\n    def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None):\r\n        if field_name == \"flow_name\":\r\n            build_config[\"flow_name\"][\"options\"] = self.get_flow_names()\r\n        return build_config\r\n\r\n    @staticmethod\r\n    def extract_component_output(run_output: List[Any], component_name: str) -> Union[Dict[str, Any], None]:\r\n        logger.debug(f\"Extracting component output for: {component_name}\")\r\n        if not run_output or not isinstance(run_output[0], object) or not hasattr(run_output[0], 'outputs'):\r\n            logger.debug(f\"Invalid run_output structure: {run_output}\")\r\n            return None\r\n        \r\n        for output in run_output[0].outputs:\r\n            logger.debug(f\"Processing output: {output}\")\r\n            if hasattr(output, 'component_display_name') and component_name in output.component_display_name:\r\n                if 'Langwatch Evaluator' in output.component_display_name:\r\n                    if isinstance(output.outputs.get('trace_url'), dict):\r\n                        trace_url = output.outputs['trace_url'].get('message', '')\r\n                    else:\r\n                        trace_url = str(output.outputs.get('trace_url', ''))\r\n                    logger.debug(f\"Extracted Langwatch trace URL: {trace_url}\")\r\n                    return {\r\n                        'trace_url': trace_url\r\n                    }\r\n                elif 'Chat Output' in output.component_display_name:\r\n                    message = output.results.get('message', {})\r\n                    if isinstance(message, dict):\r\n                        text = message.get('text', '')\r\n                    elif hasattr(message, 'text'):\r\n                        text = message.text\r\n                    else:\r\n                        text = str(message)\r\n                    logger.debug(f\"Extracted Chat Output text: {text}\")\r\n                    return {\r\n                        'text': text\r\n                    }\r\n        logger.debug(f\"No matching output found for component: {component_name}\")\r\n        return None\r\n\r\n    async def execute_flow_batch(self) -> List[Data]:\r\n        logger.debug(\"Starting execute_flow_batch method\")\r\n        self.log(\"Starting execute_flow_batch method\")\r\n        try:\r\n            email = self.email_address.text\r\n            user_name = self.user_name.text\r\n\r\n            if not self.validate_email(email):\r\n                raise ValueError(f\"Invalid email address: {email}\")\r\n            \r\n            flow_name = self._attributes.get(\"flow_name\")\r\n            input_data_list = self.input_data_list\r\n            output_data_list = []\r\n        \r\n            for index, input_data in enumerate(input_data_list, start=1):\r\n                logger.debug(f\"Processing input data {index}/{len(input_data_list)}\")\r\n                self.log(f\"Processing input data {index}/{len(input_data_list)}\")\r\n                if not isinstance(input_data, Data) or 'question' not in input_data.data:\r\n                    logger.debug(f\"Skipping invalid input data: {input_data}\")\r\n                    self.log(f\"Skipping invalid input data: {input_data}\")\r\n                    continue\r\n\r\n                input_text = input_data.data['question']\r\n                question_id = input_data.data['id']\r\n                ground_truth = input_data.data['ground_truth']\r\n                \r\n                logger.debug(f\"Running flow for input: {input_text}\")\r\n                result = await self.run_flow(\r\n                    inputs={\"input_value\": input_text},\r\n                    flow_name=flow_name,\r\n                    tweaks={\r\n                        \"Langwatch Evaluator\": {\r\n                            \"question_id\": question_id,\r\n                            \"ground_truth\": ground_truth,\r\n                            \"user_email\": email,\r\n                            \"user_name\": user_name\r\n                        },\r\n                    },\r\n                    output_type=\"debug\"\r\n                )\r\n                \r\n                logger.debug(f\"Run flow result: {result}\")\r\n                self.log(f\"Run flow result: {result}\")\r\n                \r\n                chat_output = self.extract_component_output(result, \"Chat Output\")\r\n                langwatch_output = self.extract_component_output(result, \"Langwatch Evaluator\")\r\n                \r\n                response = chat_output['text'] if chat_output else \"Response not found\"\r\n                trace_url = langwatch_output['trace_url'] if langwatch_output else \"Trace URL not found\"\r\n                \r\n                output_data = Data(data={\r\n                    \"id\": question_id,\r\n                    \"question\": input_text,\r\n                    \"ground_truth\": ground_truth,\r\n                    \"flow_response\": response,\r\n                    \"langwatch_trace_url\": trace_url\r\n                })\r\n                output_data_list.append(output_data)\r\n                logger.debug(f\"Added output data for input {index}\")\r\n                self.log(f\"Added output data for input {index}\")\r\n\r\n            logger.debug(f\"Finished processing all inputs. Total outputs: {len(output_data_list)}\")\r\n            self.log(f\"Finished processing all inputs. Total outputs: {len(output_data_list)}\")\r\n            self.status = output_data_list\r\n            return output_data_list\r\n        \r\n        except ValueError as ve:\r\n            logger.error(f\"Validation error: {str(ve)}\")\r\n            self.log(f\"Validation error: {str(ve)}\")\r\n            self.status = str(ve)\r\n            raise ve\r\n        except Exception as e:\r\n            error_message = f\"Error executing flow batch: {str(e)}\"\r\n            logger.error(error_message)\r\n            logger.exception(\"Full exception traceback:\")\r\n            self.log(error_message)\r\n            self.log(\"Full exception traceback:\")\r\n            self.status = error_message\r\n            return [Data(data={\"error\": error_message})]\r\n        finally:\r\n            logger.debug(\"Finished execute_flow_batch method\")\r\n            self.log(\"Finished execute_flow_batch method\")","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"email_address":{"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"email_address","value":"imtiazx@protonmail.com","display_name":"Email Address","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Email address for notifications or identification.","title_case":false,"type":"str","_input_type":"MessageInput"},"flow_name":{"trace_as_metadata":true,"options":["Test - IA Devs India - Week 1","Final - IA Devs India - Week 1","week_2_rag_flow_example","Evaluation Flow - AI Devs Week 2","Evaluation Flow - AI Devs Week 2 (1)","week_2_rag_flow_example (1)","week_2_rag_flow_example (2)","Evaluation Flow - AI Devs Week 2 (2)","RAG - Multi Query","Final Solution - Challenge 2.1","RAG - Multi Query (1) (1)","RAG - Multi Query (1) (2)"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"flow_name","value":"Final Solution - Challenge 2.1","display_name":"Flow Name","advanced":false,"dynamic":false,"info":"The name of the flow to run.","refresh_button":true,"title_case":false,"type":"str","_input_type":"DropdownInput","load_from_db":false},"user_name":{"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"user_name","value":"Imtiaz Mollah","display_name":"User Name","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Full name of the user.","title_case":false,"type":"str","_input_type":"MessageInput"}},"description":"Execute a specific Langflow by name with a list of input messages and email address.","icon":"list-restart","base_classes":["Data"],"display_name":"Flow Evaluator- AI Devs","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"output_data_list","display_name":"Output Data List","method":"execute_flow_batch","value":"__UNDEFINED__","cache":true}],"field_order":["input_data_list","flow_name","email_address","user_name"],"beta":false,"edited":true,"lf_version":"1.0.17"},"id":"BatchFlowExecutorComponent-BehTi"},"selected":false,"width":384,"height":546,"positionAbsolute":{"x":992.3372559075567,"y":191.6643185144561},"dragging":false}],"edges":[{"source":"FileCSVComponent-xIEjA","target":"BatchFlowExecutorComponent-BehTi","sourceHandle":"{≈ìdataType≈ì:≈ìFileCSVComponent≈ì,≈ìid≈ì:≈ìFileCSVComponent-xIEjA≈ì,≈ìname≈ì:≈ìdata_list≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}","targetHandle":"{≈ìfieldName≈ì:≈ìinput_data_list≈ì,≈ìid≈ì:≈ìBatchFlowExecutorComponent-BehTi≈ì,≈ìinputTypes≈ì:[≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}","data":{"targetHandle":{"fieldName":"input_data_list","id":"BatchFlowExecutorComponent-BehTi","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"FileCSVComponent","id":"FileCSVComponent-xIEjA","name":"data_list","output_types":["Data"]}},"selected":false,"className":"","id":"reactflow__edge-FileCSVComponent-xIEjA{≈ìdataType≈ì:≈ìFileCSVComponent≈ì,≈ìid≈ì:≈ìFileCSVComponent-xIEjA≈ì,≈ìname≈ì:≈ìdata_list≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}-BatchFlowExecutorComponent-BehTi{≈ìfieldName≈ì:≈ìinput_data_list≈ì,≈ìid≈ì:≈ìBatchFlowExecutorComponent-BehTi≈ì,≈ìinputTypes≈ì:[≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}"},{"source":"BatchFlowExecutorComponent-BehTi","sourceHandle":"{≈ìdataType≈ì:≈ìBatchFlowExecutorComponent≈ì,≈ìid≈ì:≈ìBatchFlowExecutorComponent-BehTi≈ì,≈ìname≈ì:≈ìoutput_data_list≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}","target":"CSVAppender-shqpS","targetHandle":"{≈ìfieldName≈ì:≈ìdata≈ì,≈ìid≈ì:≈ìCSVAppender-shqpS≈ì,≈ìinputTypes≈ì:[≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}","data":{"targetHandle":{"fieldName":"data","id":"CSVAppender-shqpS","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"BatchFlowExecutorComponent","id":"BatchFlowExecutorComponent-BehTi","name":"output_data_list","output_types":["Data"]}},"id":"reactflow__edge-BatchFlowExecutorComponent-BehTi{≈ìdataType≈ì:≈ìBatchFlowExecutorComponent≈ì,≈ìid≈ì:≈ìBatchFlowExecutorComponent-BehTi≈ì,≈ìname≈ì:≈ìoutput_data_list≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}-CSVAppender-shqpS{≈ìfieldName≈ì:≈ìdata≈ì,≈ìid≈ì:≈ìCSVAppender-shqpS≈ì,≈ìinputTypes≈ì:[≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}","className":""}],"viewport":{"x":-486.28278733350317,"y":78.89939902497099,"zoom":1.3417047120817713}},"description":"This flow contains two main components, one for inputting the questions and another for selecting the flow to be evaluated.\nThe flow will be executed in a loop for each question in the dataset.\nAt the end, you will have a list with the inputs, outputs, and the trace URL, and you can save it in a CSV.","name":"Final Solution - Challenge 2.2","last_tested_version":"1.0.17","endpoint_name":null,"is_component":false}